ðŸŸ¦ Interface Segregation Principle (ISP) â€” Simple Definition

ðŸ‘‰ Clients should NOT be forced to depend on methods they donâ€™t use.

Yani:
Badi, fat interface â†’ Galat
Chhoti, focused, purpose-based interfaces â†’ Sahi

ðŸŸ© Ye Kyu Important Hai?

Agar interface me bahut saare methods honge:
Har class ko unwanted methods implement karna padega
Blank implementations likhne padenge
Maintenance mushkil ho jaati hai
Behavior inconsistent ho jata hai

Isiliye ISP kehta hai:
ðŸ‘‰ Interface ko small parts me break karo â€” har ek ka ek hi responsibility.

ðŸŸ§ Problem â€” Fat Interface
Example:
interface Worker {
    void work();
    void eat();
    void sleep();
}

Ab do classes hain:
class HumanWorker implements Worker {
    work() {â€¦}
    eat() {â€¦}
    sleep() {â€¦}
}

Butâ€¦
class RobotWorker implements Worker {
    work() {â€¦}
    eat() { }     // Robots don't eat â†’ useless
    sleep() { }   // Robots don't sleep â†’ useless
}
Robot ko unnecessary methods implement karne pad rahe â†’ ISP violated.


ðŸŸ© ISP Solution â€” Split Interfaces
Split big interface into separate roles:

interface Workable {
    void work();
}

interface Eatable {
    void eat();
}

interface Sleepable {
    void sleep();
}

Now classes implement only what they need:

âœ” Human: 
class HumanWorker implements Workable, Eatable, Sleepable { â€¦ }

âœ” Robot:
class RobotWorker implements Workable { â€¦ }
